package de.ruu.app.jeeeraaah.common.fx;

import de.ruu.app.jeeeraaah.common.Task;
import de.ruu.app.jeeeraaah.common.TaskGroup;
import de.ruu.app.jeeeraaah.common.bean.TaskBean;
import de.ruu.app.jeeeraaah.common.bean.TaskGroupBean;
import de.ruu.app.jeeeraaah.common.map.Map_TaskGroup_FXBean_Bean;
import de.ruu.lib.jpa.core.Entity;
import de.ruu.lib.mapstruct.ReferenceCycleTracking;
import jakarta.annotation.Nullable;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableSet;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.experimental.Accessors;

import java.util.Collections;
import java.util.Optional;
import java.util.Set;

import static de.ruu.lib.util.BooleanFunctions.not;
import static java.util.Objects.isNull;

// EqualsAndHashCode is for documenting the intent of manually created equals and hashCode methods
@EqualsAndHashCode(onlyExplicitlyIncluded = true, callSuper = false, doNotUseGetters = true)
@Getter
@Accessors(fluent = true)
public class TaskGroupFXBean
		implements
				TaskGroup<TaskFXBean>,
				Entity<Long>
{
	@EqualsAndHashCode.Include // documents intent of including id for equals() and hashCode() but both methods are
	                           // manually created
	@Setter(AccessLevel.NONE) @Nullable private Long  id;
	@Setter(AccessLevel.NONE) @Nullable private Short version;

	private final StringProperty nameProperty        = new SimpleStringProperty();
	private final StringProperty descriptionProperty = new SimpleStringProperty();

	@Nullable private ObservableSet<TaskFXBean> tasks;

	/**
	 * hand-made required args constructor to guarantee usage of hand made accessors.
	 * @param name non-empty name
	 */
	public TaskGroupFXBean(@NonNull String name) { name(name); }

	/**
	 * create a new task group fx bean from an existing entity
	 * <p>
	 * This constructor is used by mapstruct to create a new task group fx bean from an existing one.
	 * @param in   the existing entity, must not be {@code null}
	 * @param name non-empty name, must not be {@code null}, empty or blank
	 */
	public TaskGroupFXBean(@NonNull Entity<Long> in, @NonNull String name)
	{
		this.id      = in.id();
		this.version = in.version();
		name(name);
	}

	@Override public boolean equals(Object o)
	{
		if (this == o) return true;
		if (!(o instanceof TaskGroupFXBean other)) return false;

		if (this.id != null && other.id != null) return id.equals(other.id);
		return false;
	}

	@Override public int hashCode() { return id != null ? id.hashCode() : System.identityHashCode(this); }

	//////////////////////
	// mapstruct callbacks
	//////////////////////

	/** {@link TaskGroupBean} -> {@link TaskGroupFXBean} */
	// callbacks for mapstruct
	public void beforeMapping(@NonNull TaskGroupBean in, @NonNull ReferenceCycleTracking context)
	{
		// set fields that can not be modified from outside
		id      = in.id     ();
		version = in.version();
		// mapping of other fields is done via mapstruct using java-beans accessors
	}
	/** {@link TaskGroupBean} -> {@link TaskGroupFXBean} */
	public void afterMapping(@NonNull TaskGroupBean in, @NonNull ReferenceCycleTracking context)
	{
		if (in.tasks().isPresent())
		{
			Set<TaskBean> relatedTasks = in.tasks().get();
			for (TaskBean relatedTask : relatedTasks)
			{
				// check if related task was already mapped
				TaskFXBean relatedTaskMapped = context.get(relatedTask, TaskFXBean.class);
				if (isNull(relatedTaskMapped))
					// start new mapping for related task
					addTask(relatedTask.toFXBean(context));
				else
					// use already mapped related task
					addTask(relatedTaskMapped);
			}
		}
	}

	public @NonNull TaskGroupBean toBean(ReferenceCycleTracking context)
	{
		return Map_TaskGroup_FXBean_Bean.INSTANCE.map(this, context);
	}

	////////////////////////////////////////////////////////////////////////
	// fluent style accessors generated by lombok if not specified otherwise
	////////////////////////////////////////////////////////////////////////

	@Override @NonNull public String          name() { return nameProperty.getValue(); }
	@Override @NonNull public TaskGroupFXBean name(@NonNull String name)
	{
		nameProperty.setValue(name);
		return this;
	}

	@Override          public Optional<String> description() { return Optional.ofNullable(descriptionProperty.getValue()); }

	@Override @NonNull public TaskGroupFXBean  description(@Nullable String description)
	{
		descriptionProperty.setValue(description);
		return this;
	}

	@Override public Optional<Set<TaskFXBean>> tasks()
	{
		if (isNull(tasks)) return Optional.empty();
		return Optional.of(Collections.unmodifiableSet(tasks));
	}

	/**
	 * call this method from {@link TaskFXBean} constructor and {@link TaskFXBean#taskGroup(TaskGroupFXBean)} only
	 * @param task the {@link Task} to be added as predecessor
	 * @return {@code true} if the task was added, {@code false} if the task was already present in this task group
	 */
	protected boolean addTask(TaskFXBean task) { return nonNullTasks().add(task); }

	@Override public boolean removeTask(TaskFXBean task)
	{
		if (not(tasks == null)) return tasks.remove(task);
		return false;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	// java bean style accessors for those who do not work with fluent style accessors (mapstruct)
	//////////////////////////////////////////////////////////////////////////////////////////////

	public String getName()                     { return nameProperty.getValue(); }
	public void   setName(@NonNull String name) {        name(name);              }

	@Nullable
	public String getDescription()                   { return descriptionProperty.getValue(); }
	public void   setDescription(String description) {        description(description);       }

	private @NonNull Set<TaskFXBean> nonNullTasks()
	{
		if (isNull(tasks)) tasks = FXCollections.observableSet();
		return tasks;
	}
}