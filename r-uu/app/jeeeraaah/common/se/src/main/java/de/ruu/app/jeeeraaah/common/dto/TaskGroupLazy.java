package de.ruu.app.jeeeraaah.common.dto;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import de.ruu.app.jeeeraaah.common.bean.TaskBean;
import de.ruu.app.jeeeraaah.common.bean.TaskGroupBean;
import de.ruu.app.jeeeraaah.common.jpa.TaskGroupEntityJPA;
import de.ruu.app.jeeeraaah.common.map.Map_TaskGroup_Lazy_Bean;
import de.ruu.lib.jpa.core.Entity;
import de.ruu.lib.util.Strings;
import jakarta.annotation.Nullable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility.ANY;
import static java.util.Objects.nonNull;

/** Transfer object for task groups with the ids of their related tasks. */
@JsonAutoDetect(fieldVisibility = ANY)
@EqualsAndHashCode
@ToString
@Slf4j
@Getter
@Accessors(fluent = true)
public class TaskGroupLazy implements Entity<Long>
{
	private @NonNull  Long   id;
	private @NonNull  Short  version;
	private @NonNull  String name;

	private final @NonNull  Set<Long> taskIds = new HashSet<>();

	///////////////
	// constructors
	///////////////

	public TaskGroupLazy() { } // for jackson

	/**
	 * hand-made required args constructor to guarantee usage of hand made accessors.
	 * @param name non-empty name
	 */
	public TaskGroupLazy(@NonNull String name) { name(name); }

	/**
	 * create a new task group lazy from an existing entity
	 * <p>
	 * This constructor is used by mapstruct to create a new task group entity from an existing one.
	 * @param in   the existing entity, must not be {@code null}
	 * @param name non-empty name, must not be {@code null}, empty or blank
	 */
	public TaskGroupLazy(@NonNull de.ruu.lib.jpa.core.Entity<Long> in, @NonNull String name)
	{
		this.id      = in.id();
		this.version = in.version();
		name(name);
	}

	////////////////////////////////////////////////////////////////////////
	// fluent style accessors generated by lombok if not specified otherwise
	////////////////////////////////////////////////////////////////////////

	/**
	 * manually created fluent setter with extra parameter check (see throws documentation)
	 * @param name non-null, non-empty, non-blank
	 * @return {@code this}
	 * @throws IllegalArgumentException if {@code name} parameter is empty or blank
	 * @throws NullPointerException     if {@code name} parameter is {@code null}
	 */
	@NonNull public TaskGroupLazy name(@NonNull String name)
	{
		if (Strings.isEmptyOrBlank(name)) throw new IllegalArgumentException("name must not be empty nor blank");
		this.name = name;
		return this;
	}

//	public Optional<String> description() { return Optional.ofNullable(description); }

	//////////////////////
	// mapstruct callbacks
	//////////////////////

	public void beforeMapping(@NonNull TaskGroupEntityJPA in)
	{
		// set fields that cannot be modified from outside
		id      = in.getId();
		version = in.getVersion();
		// mapping of other fields is done via mapstruct using java-beans accessors
	}
	public void afterMapping(@NonNull TaskGroupEntityJPA in)
	{
		if (in.tasks().isPresent()) { in.tasks().get().forEach(t -> taskIds.add(t.getId())); }
	}

	//////////////////////////////////////////////////////////////////////////////////////////////
	// java bean style accessors for those who do not work with fluent style accessors (mapstruct)
	//////////////////////////////////////////////////////////////////////////////////////////////

	@Override public @Nullable Long  getId     () { return id; }
	@Override public @Nullable Short getVersion() { return version; }

	public @NonNull String getName()                     { return name; }
	public          void   setName(@NonNull String name) {   name(name); }

	/** * @return a new {@link TaskGroupBean} with the same id, version and name but without taskIds */
	public TaskGroupBean toBeanWithoutRelated() { return Map_TaskGroup_Lazy_Bean.INSTANCE.map(this); }

	public TaskGroupBean toBean(@NonNull Set<TaskLazy> tasksLazy)
	{
		// create a task group bean from the lazy task group, taskGroupBean will not have any tasks yet
		TaskGroupBean result = toBeanWithoutRelated();

		// create task beans from lazy tasks, these will not have any related tasks yet
		// store task beans and lazy tasks in maps
		Map<Long, TaskBean> taskBeansById = new HashMap<>();
		Map<Long, TaskLazy> tasksLazyById = new HashMap<>();

		for (TaskLazy taskLazy : tasksLazy)
		{
			// create a task bean from the lazy task, this will not have any related tasks yet
			TaskBean taskBean = taskLazy.toBeanWithoutRelated(result);
			log.debug("task bean created: {}", taskBean);
			// add the task bean to the task beans map and the task lazy to the lazy tasks map
			taskBeansById.put(taskBean.id(), taskBean);
			tasksLazyById.put(taskBean.id(), taskLazy);
		}

		if (result.tasks().isPresent())
		{
			// now we have everything in place to populate the tasks with their related tasks
			Set<TaskBean> groupTasksAsBeans = result.tasks().get();
			log.debug("task group bean {} has {} tasks", result, groupTasksAsBeans.size());
			for (TaskBean task : groupTasksAsBeans)
			{
				// populate the task bean with its related tasks
				populateTaskBean(task, tasksLazyById, taskBeansById);
			}
		}
		else log.debug("task group {} bean has no tasks", result);

		return result;
	}

	/**
	 * Populate the given task bean with super task, sub tasks, predecessors and successors. The tree structure of the
	 * task is iterated along the sub tasks relation. No navigation (back) is done via the super task relation.
	 * <p>
	 * This method is recursive and will populate all tasks related via sub tasks. So this method's first invocation is
	 * usually done with a main task (which has no super task) of a task group
	 *
	 * @param task          the task bean to populate
	 * @param tasksLazyById map of lazy tasks by their id
	 * @param taskBeansById map of task beans by their id
	 */
	private void populateTaskBean(TaskBean task, Map<Long, TaskLazy> tasksLazyById, Map<Long, TaskBean> taskBeansById)
	{
		TaskLazy taskLazy = tasksLazyById.get(task.id()); // get the lazy task for the given task bean

		if (nonNull(taskLazy.superTaskId())) task.superTask(taskBeansById.get(taskLazy.superTaskId()));

		taskLazy.subTaskIds    ().forEach(id -> task.addSubTask    (taskBeansById.get(id)));
		taskLazy.predecessorIds().forEach(id -> task.addPredecessor(taskBeansById.get(id)));
		taskLazy.successorIds  ().forEach(id -> task.addSuccessor  (taskBeansById.get(id)));

		if (task.subTasks().isPresent())
		{
//			for (TaskBean taskBean : task.subTasks().get())
//			{
//				// recursively populate the sub tasks of the task bean
//				populateTaskBean(taskBean, tasksLazyById, taskBeansById);
//			}
			task.subTasks()
					.map(subs -> new ArrayList<>(subs)) // copy to avoid concurrent modification
					.ifPresent
					(
							copy ->
							{
								for (TaskBean subTaskBean : copy)
								{
									// recursively populate the sub tasks of the task bean
									populateTaskBean(subTaskBean, tasksLazyById, taskBeansById);
								}
							}
					);
		}
	}
}