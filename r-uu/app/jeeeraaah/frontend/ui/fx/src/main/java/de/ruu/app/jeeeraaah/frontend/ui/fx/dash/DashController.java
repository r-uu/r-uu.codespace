package de.ruu.app.jeeeraaah.frontend.ui.fx.dash;

import de.ruu.app.jeeeraaah.common.api.bean.TaskBean;
import de.ruu.app.jeeeraaah.common.api.bean.TaskGroupBean;
import de.ruu.app.jeeeraaah.common.api.domain.TaskGroupFlat;
import de.ruu.app.jeeeraaah.common.api.domain.TaskGroupLazy;
import de.ruu.app.jeeeraaah.common.api.domain.TaskLazy;
import de.ruu.app.jeeeraaah.common.api.mapping.Mappings;
import de.ruu.app.jeeeraaah.frontend.ui.fx.model.TaskGroupFXBean;
import de.ruu.app.jeeeraaah.frontend.ui.fx.task.view.hierarchy.predecessor.TaskHierarchyPredecessors;
import de.ruu.app.jeeeraaah.frontend.ui.fx.task.view.hierarchy.successor.TaskHierarchySuccessors;
import de.ruu.app.jeeeraaah.frontend.ui.fx.task.view.hierarchy.supersub.TaskHierarchySuperSubTasks;
import de.ruu.app.jeeeraaah.frontend.ui.fx.taskgroup.edit.TaskGroupEditor;
import de.ruu.app.jeeeraaah.frontend.ui.fx.taskgroup.selector.TaskGroupSelector;
import de.ruu.app.jeeeraaah.frontend.ui.fx.taskgroup.selector.TaskGroupSelectorService.TaskGroupSelectorComponentReadyEvent;
import de.ruu.app.jeeeraaah.frontend.ui.fx.taskgroup.selector.TaskGroupSelectorService.TaskGroupSelectorComponentReadyEvent.TaskGroupSelectorComponentReadyEventDispatcher;
import de.ruu.app.jeeeraaah.frontend.ws.rs.TaskGroupServiceClient;
import de.ruu.app.jeeeraaah.frontend.ws.rs.TaskServiceClient;
import de.ruu.lib.fx.FXUtil;
import de.ruu.lib.fx.comp.FXCAppStartedEvent;
import de.ruu.lib.fx.comp.FXCAppStartedEvent.FXCAppStartedEventDispatcher;
import de.ruu.lib.fx.comp.FXCController.DefaultFXCController;
import de.ruu.lib.fx.control.dialog.ExceptionDialog;
import de.ruu.lib.mapstruct.ReferenceCycleTracking;
import de.ruu.lib.ws.rs.NonTechnicalException;
import de.ruu.lib.ws.rs.TechnicalException;
import jakarta.inject.Inject;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.geometry.Insets;
import javafx.scene.control.Button;
import javafx.scene.control.ButtonType;
import javafx.scene.control.Dialog;
import javafx.scene.control.DialogPane;
import javafx.scene.control.TreeItem;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.CornerRadii;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import static de.ruu.app.jeeeraaah.common.api.domain.Task.COMPARATOR;
import static de.ruu.app.jeeeraaah.frontend.common.mapping.Mappings.toBean;
import static de.ruu.app.jeeeraaah.frontend.common.mapping.Mappings.toFXBean;
import static de.ruu.lib.fx.FXUtil.getStage;
import static java.util.Objects.isNull;
import static javafx.scene.control.ButtonBar.ButtonData.OK_DONE;
import static javafx.scene.control.ButtonType.CANCEL;
import static javafx.scene.control.ButtonType.OK;
import static javafx.scene.layout.Priority.ALWAYS;

/**
 * Java FX Component View Controller
 * <p>
 * generated by {@code de.ruu.lib.gen.java.fx.comp.GeneratorFXCViewController} at 2025.03.20 12:21:07:964
 * <p>
 * The planned behaviour is as follows:
 * - the controller fetches all task groups from the server in lazy mode (just tasks ids inside lazy task groups)
 * - the user selects a task group in the groupSelector
 * - the controller fetches all tasks in the selected task group from the server in lazy mode, lazy mode means that
 *   ids of related tasks are fetched, but not the related tasks themselves
 * - however, because we have all tasks in the task group and the ids of the related tasks, we can create the trees of
 *   super and sub tasks in the tree view as well as the tree of predecessors and successors
 */
@Slf4j
class DashController extends DefaultFXCController<Dash, DashService> implements DashService
{
	@FXML private HBox hBxGroupSelector;

	@FXML private AnchorPane nchrPnPredecessors;
	@FXML private AnchorPane nchrPnSuperSubTasks;
	@FXML private AnchorPane nchrPnSuccessors;

	@FXML private Button buttonAdd;
	@FXML private Button buttonEdit;
	@FXML private Button buttonRemove;

	@FXML private Button buttonExit;

	// inject components that are used in the user interface
	@Inject private TaskGroupSelector taskGroupSelector;

	@Inject private TaskHierarchyPredecessors taskHierarchyPredecessors;
	@Inject private TaskHierarchySuperSubTasks taskHierarchySuperSubTasks;
	@Inject private TaskHierarchySuccessors taskHierarchySuccessors;

	// inject service clients that are used to fetch data from the server
	@Inject private TaskGroupServiceClient taskGroupServiceClient;
	@Inject private TaskServiceClient      taskServiceClient;

	@Inject private TaskGroupEditor taskGroupEditor;

	@Inject private FXCAppStartedEventDispatcher                   eventDispatcherFXCAppStarted;
	@Inject private TaskGroupSelectorComponentReadyEventDispatcher eventDispatcherTaskGroupSelectorReady;

	@Inject private MainTaskBeansBuilder mainTaskBeansBuilder;

	@Override @FXML protected void initialize()
	{
		eventDispatcherFXCAppStarted         .add(e -> onAppStarted(e));
		eventDispatcherTaskGroupSelectorReady.add(e -> onTaskGroupSelectorComponentReady((TaskGroupSelectorComponentReadyEvent) e));

		buttonExit  .setBackground(new Background(new BackgroundFill(Color.WHITE, CornerRadii.EMPTY, Insets.EMPTY)));
		buttonRemove.setBackground(new Background(new BackgroundFill(Color.WHITE, CornerRadii.EMPTY, Insets.EMPTY)));

		buttonAdd.setOnAction(event -> onAdd(event));

		// initialise (fxml-inject) all internal fx-controls in groupSelector using groupSelector.getLocalRoot
		HBox.setHgrow(taskGroupSelector.localRoot(), ALWAYS);
		hBxGroupSelector.getChildren().add(taskGroupSelector.localRoot());

		// initialise (fxml-inject) all internal fx-controls in taskHierarchyViews and add them to the anchor panes
		nchrPnPredecessors .getChildren().add(taskHierarchyPredecessors .localRoot());
		nchrPnSuperSubTasks.getChildren().add(taskHierarchySuperSubTasks.localRoot());
		nchrPnSuccessors   .getChildren().add(taskHierarchySuccessors   .localRoot());

		FXUtil.setAnchorsInAnchorPaneTo(taskHierarchyPredecessors .localRoot(), 0);
		FXUtil.setAnchorsInAnchorPaneTo(taskHierarchySuperSubTasks.localRoot(), 0);
		FXUtil.setAnchorsInAnchorPaneTo(taskHierarchySuccessors   .localRoot(), 0);

		taskHierarchySuperSubTasks
				.service()
				.selectedItem()
				.addListener((obs, old, val) -> onSelectedSuperSubTaskChanged(obs, old, val));

		fetchGroupsAndPopulateTaskGroupSelector();
	}

	private void fetchGroupsAndPopulateTaskGroupSelector()
	{
		// create and populate groups
		try
		{
			Set<TaskGroupFlat> groups = taskGroupServiceClient.findAllFlat();

			// now we are ready to hand over the groups to groupSelector
			taskGroupSelector.service().items(groups);
		}
		catch (TechnicalException | NonTechnicalException e)
		{
			ExceptionDialog.showAndWait("failure fetching task groups from backend", e);
		}
	}

	/**
	 * registration of a listener for groupSelector.service().selectedProperty() has to wait for a component ready event
	 * to make sure all internal initialisations are finished
	 *
	 * @param e the event that indicates that the groupSelector component is ready
	 */
	private void onTaskGroupSelectorComponentReady(TaskGroupSelectorComponentReadyEvent e)
	{
		// make sure the listener method is called whenever the selected group in groupSelector changes
		taskGroupSelector.service().selectedTaskGroupProperty().addListener((obs, old, val) -> onSelectedGroupChanged(val));
	}

	private void onSelectedGroupChanged(TaskGroupFlat selectedTaskGroupDTOFlat)
	{
		if (isNull(selectedTaskGroupDTOFlat)) return;

		// fetch the task group with the ids of all it's tasks from the server
		try
		{
			Optional<TaskGroupLazy> optionalGroupLazy = taskGroupServiceClient.findGroupLazy(selectedTaskGroupDTOFlat.id());
			if (optionalGroupLazy.isPresent())
			{
				TaskGroupLazy groupLazy = optionalGroupLazy.get();

				// fetch all of group's tasks together with the ids of their related tasks from the server
				Set<TaskLazy> groupTasksLazy = null;
				try
				{
					groupTasksLazy = taskServiceClient.findTasksLazy(groupLazy.taskIds());

					// build the main tasks as fully populated task beans from the lazy tasks
					List<TaskBean> mainTasks = new ArrayList<>(mainTaskBeansBuilder.build(groupLazy, groupTasksLazy));
					mainTasks.sort(COMPARATOR);

					taskHierarchySuperSubTasks.service().populate(mainTasks);
					taskHierarchySuperSubTasks.service().focusRootItem();

					TaskGroupBean taskGroupBean = Mappings.toBean(groupLazy, new ReferenceCycleTracking());

					taskHierarchyPredecessors .service().activeTaskGroupProperty().setValue(taskGroupBean);
					taskHierarchySuperSubTasks.service().activeTaskGroupProperty().setValue(taskGroupBean);
					taskHierarchySuccessors   .service().activeTaskGroupProperty().setValue(taskGroupBean);

					taskHierarchySuperSubTasks.service().activeTaskGroupProperty().addListener(
							(obs, old, act) -> onActiveTaskPropertyChangedInSuperSubTaskHierarchy(act));
				}
				catch (TechnicalException | NonTechnicalException e)
				{
					ExceptionDialog.showAndWait("failure fetching tasks from backend for group with id: " + groupLazy.id(), e);
				}
			}
			else log.debug("no lazy group could be retrieved");
		}
		catch (TechnicalException | NonTechnicalException e)
		{
			ExceptionDialog.showAndWait("failure fetching task group from backend", e);
		}
	}

	private void onAppStarted(FXCAppStartedEvent e) { getStage(hBxGroupSelector).ifPresent(s -> s.setTitle("jeee RAAAH - dashboard")); }

	private void onAdd(ActionEvent event)
	{
		Dialog<TaskGroupFXBean> dialog = new Dialog<>();

		DialogPane pane = dialog.getDialogPane();
		pane.setContent(taskGroupEditor.localRoot());
		pane.getButtonTypes().addAll(CANCEL, OK);

		dialog.setTitle("new task group");
		dialog.setResultConverter(this::dialogResultConverterFXBean);

		// populate editor with new item, call to service() has to be done after call to localRoot() to make sure internal
		// java fx bindings can be established (see initialize)
		TaskGroupBean   taskGroupBean   = new TaskGroupBean("new task group");
		TaskGroupFXBean taskGroupFXBean = toFXBean(taskGroupBean, new ReferenceCycleTracking());

		taskGroupEditor.service().taskGroup(taskGroupFXBean);

		Optional<TaskGroupFXBean> optional = dialog.showAndWait();

		if (optional.isPresent())
		{
			taskGroupFXBean = optional.get();
			taskGroupBean   = toBean(taskGroupFXBean,new ReferenceCycleTracking());

			// let client create a new item in db
			try
			{
				taskGroupBean = taskGroupServiceClient.create(taskGroupBean);

				// repopulate and then focus task group selector
				fetchGroupsAndPopulateTaskGroupSelector();
			}
			catch (TechnicalException | NonTechnicalException e)
			{
				ExceptionDialog.showAndWait
				(
						"failure creating task group",
						"task\n\n" + taskGroupBean + "\n\ncould not be created",
						e.getMessage(),
						e
				);
			}
		}
	}

	private void onSelectedSuperSubTaskChanged(
			ObservableValue<? extends TreeItem<TaskBean>> obs, TreeItem<TaskBean> old, TreeItem<TaskBean> val)
	{
		taskHierarchyPredecessors.service().selectedSuperSubTaskTreeItemChanged(val);
		taskHierarchySuccessors  .service().selectedSuperSubTaskTreeItemChanged(val);
	}

	/**
	 * Whenever the active task group changes in the super/sub task hierarchy view, we have to set the new active task
	 * group in the predecessor and successor hierarchy views, too, to propagate possible changes in the active
	 * {@link TaskGroupBean#tasks()}.
	 *
	 * @param act the new active task group
	 */
	private void onActiveTaskPropertyChangedInSuperSubTaskHierarchy(TaskGroupBean act)
	{
		taskHierarchyPredecessors.service().activeTaskGroupProperty().setValue(act);
		taskHierarchySuccessors  .service().activeTaskGroupProperty().setValue(act);
	}

	private TaskGroupFXBean dialogResultConverterFXBean(ButtonType btn)
	{
		if (btn.getButtonData() == OK_DONE) return taskGroupEditor.service().taskGroup().orElse(null);
		return null;
	}
}