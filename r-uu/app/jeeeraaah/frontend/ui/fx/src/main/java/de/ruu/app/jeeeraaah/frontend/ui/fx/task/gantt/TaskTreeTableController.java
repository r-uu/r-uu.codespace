package de.ruu.app.jeeeraaah.frontend.ui.fx.task.gantt;

import de.ruu.app.jeeeraaah.common.api.bean.TaskBean;
import de.ruu.lib.fx.comp.FXCController.DefaultFXCController;
import de.ruu.lib.util.Time;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.value.ChangeListener;
import javafx.fxml.FXML;
import javafx.scene.control.TreeItem;
import javafx.scene.control.TreeTableView;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import static javafx.scene.control.SelectionMode.SINGLE;

/**
 * Java FX Component View Controller
 * <p>
 * generated by {@code de.ruu.lib.gen.java.fx.comp.GeneratorFXCViewController} at 2024.12.22 11:45:01:816
 */
@Slf4j
class TaskTreeTableController
		extends DefaultFXCController<TaskTreeTable, TaskTreeTableService>
		implements TaskTreeTableService
{
	@FXML private TreeTableView<TaskTreeTableDataItem> ttv;

	@Override
	@FXML protected void initialize()
	{
		TreeItem<TaskTreeTableDataItem> rootTreeItem = new TreeItem<>();
		ttv.setRoot(rootTreeItem);
//		ttv.setShowRoot(true); //            rootTreeItem is  top level in tree table view
		ttv.setShowRoot(false); // children of rootTreeItem are top level in tree table view

		List<TreeItem<TaskTreeTableDataItem>> rootTreeItemChildren = rootTreeItemChildren();
		rootTreeItem.getChildren().addAll(rootTreeItemChildren);

		ttv.getColumns().addAll(columns());
		ttv.getSelectionModel().setSelectionMode(SINGLE);
		ttv.getSelectionModel().selectedItemProperty().addListener(selectedItemChangeListener());
	}

	private List<TreeItem<TaskTreeTableDataItem>> rootTreeItemChildren()
	{
		List<TreeItem<TaskTreeTableDataItem>> result = new ArrayList<>();

		LocalDate startOfPeriod = LocalDate.of(2025, 1,  1);
		LocalDate endOfPeriod   = LocalDate.of(2025, 1, 31);

		DataItemFactory factory = new DataItemFactory(startOfPeriod, endOfPeriod);
		for (TaskTreeTableDataItem rootItem : factory.rootItemsInPeriod())
		{
			TreeItem<TaskTreeTableDataItem> rootTaskAsTreeItem = new TreeItem<>(rootItem);
			result.add(rootTaskAsTreeItem);
			populateRecursively(rootTaskAsTreeItem, startOfPeriod, endOfPeriod);
		}

		result.sort(
		(
				tb1, tb2) ->
				tb1.getValue().task().name().compareTo(
				tb2.getValue().task().name())
		);

		return result;
	}

	private List<TaskTreeTableColumn> columns()
	{
		List<TaskTreeTableColumn> result = new ArrayList<>();

		// add first column that displays the name of the TaskBean instance for the current table row
		TaskTreeTableColumn rootTasksColumn = new TaskTreeTableColumn("root tasks");
		rootTasksColumn.setCellValueFactory
		(
				cdfs ->
				{
					TreeItem<TaskTreeTableDataItem> treeItem      = cdfs.getValue();
					TaskTreeTableDataItem           tableDataItem = treeItem.getValue();
					TaskBean task          = tableDataItem.task();
					return new SimpleStringProperty(task.name());
				}
		);
//		rootTasksColumn.setCellValueFactory(cdf -> new ReadOnlyStringWrapper(cdf.getValue().getValue().name()));
		result.add(rootTasksColumn);

		// for each day in a given period create a column that displays the cell value factory call back value for the
		// current date (of the column) and the TaskBean of the current row
		for (LocalDate date : Time.datesInPeriod(LocalDate.of(2025, 1, 1), LocalDate.of(2025, 1, 31).plusDays(1)))
		{
			TaskTreeTableColumn ttc = new TaskTreeTableColumn(date);
			result.add(ttc);
		}
		return result;
	}

	/**
	 * Populates tree item children of {@code parentTreeItem} with tree items for each child of the {@link TaskBean} value
	 * from {@code parentTreeItem}.
	 */
	private void populateRecursively(
			TreeItem<TaskTreeTableDataItem> parentTreeItem, LocalDate startOfPeriod, LocalDate endOfPeriod)
	{
		TaskBean parentTaskBean = parentTreeItem.getValue().task();
		if (parentTaskBean.subTasks().isPresent())
		{
			Set<TaskBean> subTasks = parentTaskBean.subTasks().get();
			for (TaskBean subTask : subTasks)
			{
				TaskTreeTableDataItem dataItem = new TaskTreeTableDataItem(subTask, startOfPeriod, endOfPeriod);
				TreeItem<TaskTreeTableDataItem> treeItemChild = new TreeItem<>(dataItem);
				parentTreeItem.getChildren().add(treeItemChild);
				populateRecursively(treeItemChild, startOfPeriod, endOfPeriod);
			}
		}
	}

	private ChangeListener<? super TreeItem<TaskTreeTableDataItem>> selectedItemChangeListener()
	{
		return
				(ChangeListener<TreeItem<TaskTreeTableDataItem>>) (obs, old, newValue) -> log.debug
				(
						"\nold: {}\nnew: {}",
						old      == null ? "" : old     .getValue().task().name(),
						newValue == null ? "" : newValue.getValue().task().name()
				);
	}
}