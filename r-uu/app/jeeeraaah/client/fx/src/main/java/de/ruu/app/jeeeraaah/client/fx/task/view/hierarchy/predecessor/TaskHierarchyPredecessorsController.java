package de.ruu.app.jeeeraaah.client.fx.task.view.hierarchy.predecessor;

import de.ruu.app.jeeeraaah.client.fx.task.view.hierarchy.TaskHierarchyControllerAbstract;
import de.ruu.app.jeeeraaah.client.fx.task.view.hierarchy.predecessor.add.ActionAdd;
import de.ruu.app.jeeeraaah.client.fx.task.view.hierarchy.predecessor.add.ActionAdd.Context;
import de.ruu.app.jeeeraaah.client.rs.TaskServiceClient;
import de.ruu.app.jeeeraaah.common.bean.TaskBean;
import de.ruu.lib.fx.control.dialog.AlertDialog;
import de.ruu.lib.mapstruct.ReferenceCycleTracking;
import jakarta.inject.Inject;
import javafx.fxml.FXML;
import javafx.scene.control.TreeItem;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import static de.ruu.lib.util.BooleanFunctions.not;
import static java.util.Objects.isNull;
import static javafx.geometry.NodeOrientation.RIGHT_TO_LEFT;
import static javafx.scene.control.Alert.AlertType.ERROR;

/**
 * Java FX Component View Controller
 * <p>
 * generated by {@code de.ruu.lib.gen.java.fx.comp.GeneratorFXCViewController} at 2025.06.03 12:49:45:376
 */
@Slf4j
class TaskHierarchyPredecessorsController
		extends TaskHierarchyControllerAbstract implements TaskHierarchyPredecessorsService
{
	@Inject private TaskServiceClient taskServiceClient;

	private TreeItem<TaskBean> selectedSuperSubTaskTreeItem;
	private TreeItem<TaskBean> selectedPredecessorTreeItem;

	@Override @FXML protected void initialize()
	{
		super.initialize();

		treeView().setNodeOrientation(RIGHT_TO_LEFT);
		treeView()
				.getSelectionModel().selectedItemProperty().addListener((obs, old, act) -> selectedPredecessorTreeItem = act);

		buttonAdd   ().setOnAction(e -> onButtonAddAction   ());
		buttonRemove().setOnAction(e -> onButtonRemoveAction());
	}

	@Override public void selectedSuperSubTaskTreeItemChanged(TreeItem<TaskBean> selectedSuperSubTaskTreeItem)
	{
		this.selectedSuperSubTaskTreeItem = selectedSuperSubTaskTreeItem;

		treeView().getRoot().getChildren().clear(); // clear the predecessor tree view

		if (isNull(selectedSuperSubTaskTreeItem)) return;

		if (selectedSuperSubTaskTreeItem.getValue().predecessors().isPresent())
		{
			Set<TaskBean> predecessors = selectedSuperSubTaskTreeItem.getValue().predecessors().get();
			predecessors.forEach
			(
					predecessor -> treeView().getRoot().getChildren().add(populateTreeNode(treeView().getRoot(), predecessor))
			);
		}
	}

	@Override protected TreeItem<TaskBean> populateTreeNode(TreeItem<TaskBean> root, TaskBean task)
	{
		TreeItem<TaskBean> result = new TreeItem<>(task) { @Override public String toString() { return task.name(); } };
		task.predecessors().ifPresent(predecessors -> populateTreeNode(result, predecessors));
		return result;
	}

	private void onButtonAddAction()
	{
		if (isNull(selectedSuperSubTaskTreeItem) && isNull(selectedPredecessorTreeItem))
		{
			AlertDialog.showAndWait(
					"can not add predecessor relation",
					"no predecessor nor super/sub task is selected",
					"select a predecessor and/or\na super/sub task as target\nfor the new predecessor relation", ERROR);
			return;
		}

		new ActionAdd(
				new Context(
						selectedSuperSubTaskTreeItem,
						selectedPredecessorTreeItem == null ? treeView().getRoot() : selectedPredecessorTreeItem,
						taskServiceClient))
				.execute();
	}

	private void onButtonRemoveAction()
	{
		if (isNull(selectedPredecessorTreeItem))
		{
			AlertDialog.showAndWait(
					"can not remove predecessor relation",
					"no predecessor task is selected",
					"select a predecessor task to be removed", ERROR);
			return;
		}

		TaskBean selectedPredecessor = selectedPredecessorTreeItem.getValue();

		if (    selectedPredecessor.predecessors().isPresent() &&
		    not(selectedPredecessor.predecessors().get().isEmpty()))
		{
			AlertDialog.showAndWait(
					"can not remove predecessor relation",
					"the selected predecessor task has predecessor relations",
					"remove the predecessor relations first, then you can remove this predecessor relation",
					ERROR
			);
			return;
		}

		if (selectedPredecessor.successors().isPresent())
		{
			// remove selected predecessor for all it's successors, prepare ...
			Set<TaskBean>          successors             = selectedPredecessor.successors().get();
			ReferenceCycleTracking referenceCycleTracking = new ReferenceCycleTracking();

			for (TaskBean successor : successors)
			{
				// ... and execute
				// - remove the predecessor-successor relation in the db
				taskServiceClient.removePredecessor(
						successor.toDTO(referenceCycleTracking), selectedPredecessor.toDTO(referenceCycleTracking));
			}
			// remove the predecessor-successor relation in the ui model
			TreeItem<TaskBean> parent = selectedPredecessorTreeItem.getParent();
			if (parent != null) parent.getChildren().remove(selectedPredecessorTreeItem);
		}
	}

	private void populateTreeNode(TreeItem<TaskBean> parent, Set<TaskBean> children)
	{
		List<TaskBean> childrenAsList = new ArrayList<>(children);
		childrenAsList.sort((o1, o2) -> o1.name().compareTo(o2.name()));
		childrenAsList.forEach(child -> parent.getChildren().add(populateTreeNode(parent, child)));
	}
}