package de.ruu.app.jeeeraaah.client.fx.task.view.hierarchy;

import de.ruu.app.jeeeraaah.client.fx.task.TreeCellFactory;
import de.ruu.app.jeeeraaah.client.fx.task.TreeItemTaskBean;
import de.ruu.app.jeeeraaah.client.fx.task.edit.TaskEditor;
import de.ruu.app.jeeeraaah.client.fx.task.view.TaskViewNarrow;
import de.ruu.app.jeeeraaah.client.fx.task.view.TaskViewNarrowQualifier;
import de.ruu.app.jeeeraaah.client.ws.rs.TaskGroupServiceClient;
import de.ruu.app.jeeeraaah.client.ws.rs.TaskServiceClient;
import de.ruu.app.jeeeraaah.common.bean.TaskBean;
import de.ruu.app.jeeeraaah.common.bean.TaskGroupBean;
import de.ruu.app.jeeeraaah.common.dto.TaskEntityDTO;
import de.ruu.app.jeeeraaah.common.fx.TaskFXBean;
import de.ruu.lib.fx.comp.FXCController.DefaultFXCController;
import de.ruu.lib.fx.control.dialog.ExceptionDialog;
import de.ruu.lib.mapstruct.ReferenceCycleTracking;
import de.ruu.lib.ws.rs.NonTechnicalException;
import de.ruu.lib.ws.rs.TechnicalException;
import jakarta.inject.Inject;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.geometry.Insets;
import javafx.scene.Parent;
import javafx.scene.control.Button;
import javafx.scene.control.ButtonType;
import javafx.scene.control.Dialog;
import javafx.scene.control.DialogPane;
import javafx.scene.control.TreeItem;
import javafx.scene.control.TreeView;
import javafx.scene.layout.Background;
import javafx.scene.layout.BackgroundFill;
import javafx.scene.layout.CornerRadii;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import lombok.Getter;
import lombok.NonNull;
import lombok.experimental.Accessors;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Optional;

import static de.ruu.lib.util.BooleanFunctions.not;
import static java.util.Objects.isNull;
import static javafx.scene.control.ButtonBar.ButtonData.OK_DONE;
import static javafx.scene.control.ButtonType.CANCEL;
import static javafx.scene.control.ButtonType.OK;
import static javafx.scene.control.SelectionMode.SINGLE;
import static lombok.AccessLevel.PROTECTED;

/**
 * Java FX Component View Controller
 * <p>
 * generated by {@code de.ruu.lib.gen.java.fx.comp.GeneratorFXCViewController} at 2025.06.03 12:49:45:376
 */
@Slf4j
@Accessors(fluent = true)
public abstract class TaskHierarchyControllerAbstract
		extends DefaultFXCController<TaskHierarchyAbstract, TaskHierarchyService>
		implements TaskHierarchyService
{
	@FXML private VBox vBox;

	@Getter(PROTECTED) @FXML private TreeView<TaskBean> treeView;
	@Getter(PROTECTED) @FXML private Button             buttonAdd;
	@Getter(PROTECTED) @FXML private Button             buttonRemove;

	@FXML private Button buttonEdit;

	@Inject private TaskGroupServiceClient taskGroupServiceClient;
	@Inject private TaskServiceClient      taskServiceClient;
	@Inject private TaskEditor             taskEditor;

	@TaskViewNarrowQualifier
	@Inject protected TaskViewNarrow taskView;

	private ObjectProperty<TaskGroupBean> activeTaskGroup = new SimpleObjectProperty<>();

	@Override @FXML protected void initialize()
	{
		buttonRemove.setBackground(new Background(new BackgroundFill(Color.WHITE, CornerRadii.EMPTY, Insets.EMPTY)));

		vBox.getChildren().add(taskView.localRoot());

		treeView.setCellFactory(TreeCellFactory.cellFactory());
		treeView.setShowRoot(false);
		treeView.setRoot(new TreeItemTaskBean(new TaskBean(new TaskGroupBean("root"), "root")));

		treeView.getSelectionModel().setSelectionMode(SINGLE);
		treeView.getSelectionModel().selectedItemProperty().addListener((obs, old, act) -> onSelectedTaskChanged(act));

		buttonEdit  .setOnAction(e -> onEdit  ());
		buttonRemove.setOnAction(e -> onRemove());

//		CDIUtil.fire(new TaskHierarchyComponentReadyEvent(view(), this));
	}

	@Override public void populate(@NonNull List<TaskBean> tasks)
	{
		treeView.getRoot().getChildren().clear(); // clear previous content
		tasks.forEach(task -> treeView.getRoot().getChildren().add(populateTreeNode(treeView.getRoot(), task)));
		log.debug("populate tree view done");
	}

	// TODO: move this method to utility class
	@Override public void focusRootItem()
	{
		if (not(treeView.getRoot().isLeaf()) && not(treeView.getRoot().getChildren().isEmpty()))
		{
			TreeItem<TaskBean> firstItem = treeView.getRoot().getChildren().getFirst();
			int                firstRow  = treeView.getRow (firstItem);

			if (firstRow >= 0)
			{
				treeView.getSelectionModel().select(firstRow);
				treeView.getFocusModel().focus(firstRow);
				treeView.requestFocus();
			}
		}
	}

	@Override public ObjectProperty<TaskGroupBean> activeTaskGroupProperty() { return activeTaskGroup; }

	protected abstract TreeItem<TaskBean> populateTreeNode(TreeItem<TaskBean> root, TaskBean task);

	protected void onEdit()
	{
		TreeItem<TaskBean> selectedItem = treeView().getSelectionModel().getSelectedItem();
		if (isNull(selectedItem)) return;

		// there is a selected item, so we can edit the task
		TaskBean   taskBean   = selectedItem.getValue();
		TaskFXBean taskFXBean = taskBean.toFXBean(new ReferenceCycleTracking());

		// force editor to fxml-inject internal fx-controls
		Parent editorLocalRoot = taskEditor.localRoot();

		taskEditor.service().task(taskFXBean);

		Dialog<TaskFXBean> dialog     = new Dialog<>();
		DialogPane         dialogPane = dialog.getDialogPane();

		dialog    .setTitle("edit task");
		dialog    .setResultConverter(buttonType -> dialogResultConverterTaskFXBean(buttonType));
		dialogPane.setContent(editorLocalRoot);
		dialogPane.getButtonTypes().addAll(CANCEL, OK);

		Optional<TaskFXBean> optional = dialog.showAndWait();

		if (optional.isPresent())
		{
			taskFXBean = optional.get();
			taskBean   = taskFXBean.toBean(new ReferenceCycleTracking());

			try
			{
				taskBean = taskServiceClient.update(taskBean);

				taskView.service().populateViewFor(taskFXBean);
				selectedItem.setValue(taskBean);
			}
			catch (TechnicalException | NonTechnicalException e)
			{
				ExceptionDialog.showAndWait("failure updating task\n\n" + taskBean + "\n\n in backend", e);
			}
		}
	}

	// TODO is there no operation in the backend necessary?
	protected void onRemove()
	{
		TreeItem<TaskBean> selectedItem = treeView().getSelectionModel().getSelectedItem();
		if (isNull(selectedItem)) return;
		// there is a selected item, so we can remove the predecessor task
		TaskBean taskBean = selectedItem.getValue();
		taskBean.superTask   ().ifPresent(t -> t.removeSubTask(taskBean));
//		taskBean.subTasks    ().ifPresent(ts -> ts.forEach(t -> t.removeSuperTask  (taskBean)));
		taskBean.predecessors().ifPresent(ts -> ts.forEach(t -> t.removeSuccessor  (taskBean)));
		taskBean.successors  ().ifPresent(ts -> ts.forEach(t -> t.removePredecessor(taskBean)));
		selectedItem.setValue(taskBean);
	}

	protected void onSelectedTaskChanged(TreeItem<TaskBean> act)
	{
		if (isNull(act)) return;
		taskView.service().populateViewFor(act.getValue().toFXBean(new ReferenceCycleTracking()));
	}

	private TaskFXBean dialogResultConverterTaskFXBean(ButtonType buttonType)
	{
		if (buttonType.getButtonData() == OK_DONE) return taskEditor.service().task().orElse(null);
		return null;
	}
}